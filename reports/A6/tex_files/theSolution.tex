\section{The Solution - N Body Problem}
We began by writing our code in a file we named galsim.c. This is where all the functionality that we require is stored. We used code from graphics to be able to visualise the results of the simulation.

Within the galsim.c file, we write our main program that will enable us to calculate the evolution of a system of N particles. This file begins with calling the relevant libraries we require. Below this, we take in the variables for the graphics, gravity and the smoothing constant epsilon. To improve runtime, we have set epsilon as a constant.

Below this, we have our structs, one for the various vectors we will use and one for the particles attributes. The vector struct takes two doubles, one for $x$ and one for $y$. The particle struct takes two vectors for position and and velocity, and two doubles, one for mass and brightness. These have been ordered so that they are in the same order as the data that's read in from the gal-files.

Below this, we introduced print functions that we would use for debugging. This includes print\_vector\_info, print\_particle\_info and print\_all\_particle\_info. After this, we include a function we then call in the main function to get computation times for each optimisation.

We now look to the building of the force functions. Since the Plummer spheres force equation has smoothing involved, we looked to implement this. To do this, we built each component of the equation in separate functions. The first function to be built was $\boldsymbol{r}_{ij}$. We only computed this in one way. The next to compute was $r_{ij}^{3}$. This was implemented in two different ways.

\begin{center}
    Version 1
\end{center}

\begin{lstlisting}
double norm3(vector_t v) {
    return pow((sqrt(pow((v.x), 2) + pow((v.y), 2)) + epsilon), 3);
}
\end{lstlisting}

\begin{center}
    Version 2 - 4
\end{center}

\begin{lstlisting}{language=C}
double norm3(vector_t v) {
    double n3;

    n3 = sqrt(v.x*v.x + v.y*v.y) + epsilon;
    n3 = n3 * n3 * n3;
    return n3;
}
\end{lstlisting}

With the above versions of norm3, we then implemented them into two versions of a function to calculate the force on particle $i$ from particle $j$. To do this, we had to calculate in both the $x$ and $y$ directions. Initially, we chose to include all terms for both of these directions.

\begin{center}
    Version 1 - 2
\end{center}

\begin{lstlisting}{language=C}
vector_t force(particle_t pi, particle_t pj) {
    vector_t f;

    f.x = -(G * pi.mass * pj.mass * r_vector(pi.position, pj.position).x)
            / norm3(r_vector(pi.position, pj.position));
    f.y = -(G * pi.mass * pj.mass * r_vector(pi.position, pj.position).y)
            / norm3(r_vector(pi.position, pj.position));

    return f;
}
\end{lstlisting}

We decided then that we would calculate any repetitions in each equation just once, so that this may improve computation time.

\begin{center}
    Version 3 - 4
\end{center}

\begin{lstlisting}{language=C}
vector_t force(particle_t pi, particle_t pj) {
    vector_t f;
    vector_t r;
    double a;

    r = r_vector(pi.position, pj.position);
    a = -(G * pi.mass * pj.mass) / norm3(r);

    f.x = a * r.x;
    f.y = a * r.y;

    return f;
}
\end{lstlisting}

Now that we have functions to compute the force applied to each particle, we can now loop through each particle, and compute the total force applied to each particle.

\begin{center}
    Version 1 - 3
\end{center}

\begin{lstlisting}{language=C}
vector_t total_force(particle_t* p, int i, int N) {
    vector_t f = {0.0,0.0};

    for(int j = 0; j < N; j++) {
        if(i != j) {
            vector_t f_temp = force(p[j], p[i]);
            f.x += f_temp.x;
            f.y += f_temp.y;
        }
    }
    return f;
}
\end{lstlisting}

One final improvement we applied to this was to note that since we had the forces computed from particle $i$ to particle $j$, we also had the negative of this, so we then had the force applied from particle $j$ to particle $i$.

\begin{center}
    Version 4
\end{center}

\begin{lstlisting}{language=C}
void compute_forces(vector_t* forces, particle_t* particles, int N) {

    for(int i = 0; i < N; i++) {
        forces[i].x = 0.0;
        forces[i].y = 0.0;
    }

    for(int i = 0; i < N; i++) {

        for(int j = i + 1; j < N; j++) {
                vector_t f = force(particles[j], particles[i]);
                forces[i].x += f.x;
                forces[i].y += f.y;

                forces[j].x -= f.x;
                forces[j].y -= f.y;
        }

    }
}
\end{lstlisting}

One final thing that we used to help us was to implement timings directly into the Makefile code so that when it came to computing wall timings at the end with different optimisations, we could do this directly from the Makefile.
\newpage
